...

# 4. 시간 처리

- 시간은 여러가지 면에서 까다롭다.
  - "2023년 12월 28일 13:56 UTC" 같이 절대적인 시간, "5분"과 같이 상대적인 시간으로 구분될 수 있다.
  - "오븐에서 30분 굽기"처럼 시간의 양을 언급할수도 있다.
  - 표준 시간대, 일광 절약 시간, 윤년, 윤초 등의 복잡한 개념도 있다.

## 4.1 정수로 시간을 나타내는 것은 문제가 될 수 있다.

- 정수는 매우 일반적인 유형이기 때문에 시간을 나타내는 데 사용하는 경우 코드가 오용되기 쉽다.

### 한순간의 시간인가, 아니면 시간의 양인가?

```java
/**
 * @param message 보낼 메시지
 * @param deadline 데드라인은 초 단위다.
 *  데드라인이 경과하기까지 메시지가 전송
 *  되지 않으면 전송은 취소된다.
 * @return 메시지가 전송되면 참을 그렇지 않으면 거짓
 */
Boolean sendMessage(String message, Int64 deadline) { }
```

- 위 코드는 절대 순간을 나타내야 하는지, 시간의 양을 나타내야 하는지 모호하다.
- 주석문을 개선하면 도움이 도겠지만, 코드 계약 세부 조항에 많은 내용을 추가하는 것은 좋지 않다.

### 일치하지 않는 단위

```java
class UiSettings {
    ...

    /**
     * @return UI 메시지를 보여주는 초 단위 시간
     */
    Int63 getMessageTimeout() {
        return 5;
    }
}

...

/**
 * @param message 보여줄 메시지
 * @param timeoutMs 메시지를 보여주는 밀리초 단위의 기간
 */
void showMessage(String message, Int64 timeoutMs) { }
```

### 시간대 처리 오류
- 날짜와 순간의 차이는 미묘한 것일 수 있지만, 이 두가지를 다른 방식으로 다루지 않는다면 문제가 될 수 있다.

![그림7.6]

## 4.2 해결책: 적절한 자료구조를 사용하라
- 사용하는 언어에 가장 적합한 라이브러리를 찾기 위해 노력을 기울여야 한다.

### 양으로서의 시간과 순간으로서의 시간의 구분

```java
/**
 * @param message 보낼 메시지
 * @param deadline 데드라인은 초 단위다.
 *  데드라인이 경과하기까지 메시지가 전송
 *  되지 않으면 전송은 취소된다.
 * @return 메시지가 전송되면 참을 그렇지 않으면 거짓
 */
Boolean sendMessage(String message, Duration deadline) { }
```

- 위 코드에서 값은 한순간의 시간이 아니라 시간의 양을 나타낸다는 점은 너무나 명백하다. (Duration)

### 더 이상 단위에 대한 혼동이 없다.
- `Instant` 및 `Duration`과 같은 유형이 제공하는 또 다른 이점은 단위가 유형 내에 캡슐화되어 있다는 점이다.
- 따라서 어떤 단위가 사용되어야 하는지 설명하기 위한 계약의 세부 조항이 필요하지 않으며, 실수로 잘못된 단위를 제공하는 것이 불가능하다.

```java
class UiSettings {
    ...

    /**
     * @return UI 메시지를 보여주는 기간
     */
    Duration getMessageTimeout() {
        return Duration.ofSeconds(5);
    }
}

...

/**
 *  줄 메시지
 * @param timeoutMs 메시지를 보여주는 시간의 양
 */
void showMessage(String message, Duration timeout) { }
```

### 시간대 처리 개선
- 시간을 다루는 라이브러리는 날짜 및 시간을 나타낼 수 있는 방법을 제공한다.
- `LocalDateTime`이라는 클래스를 통해 이런 작업을 정확하게 수행할 수 있다.
- 이미 많은 고민이 있었기에 라이브러리는 견고하다. 따라서 라이브러리를 사용하는 것이 좋다.

</br>

# 5. 데이터에 대해 진실의 원천을 하나만 가져야 한다.

- 데이터는 종종 두 가지 형태로 제공된다.
  - 기본 데이터 : 코드에 제공해야 할 데이터
  - 파생 데이터 : 주어진 기본 데이터에 기반해서 코드가 계산할 수 있는 데이터

## 5.1 또 다른 진실의 원천은 유효하지 않은 상태를 초래할 수 있다.

```java
class UserAccount {
    private final Double credit;
    private final Double debit;
    private final Double balance;

    UserAccount(Double credit, Double debit, Double balance) {
        this.credit = credit;
        this.debit = debit;
        this.balance = balance;
    }
}
...

UserAccount account = new UserAccount(credit, debit, debit - credit);
```

- 위와 같은 코드는 계산이 잘못된 논리로 인스턴스를 생성할 수 있다.

## 5.2 해결책: 기본 데이터를 유일한 진실의 원천으로 사용하라.

```java
class UserAccount {
    private final Double credit;
    private final Double debit;
    private final Double balance;

    UserAccount(Double credit, Double debit, Double balance) {
        this.credit = credit;
        this.debit = debit;
        this.balance = balance;
    }

    ...

    Double getBalance() {
        return credit - debit;
    }
}
```

### 데이터 계산에 비용이 많이 드는 경우

- 비용이 많이 든다면, 그 값을 지연 계산한 후에 결과를 캐싱하는 것이 좋다.

```java
class UserAccount {
    private final ImmutableList<Transaction> transactions;

    private Double? cachedCredit;
    private Double? cachedDebit;


    UserAccount(ImmutableList<Transaction> transactions) {
        this.transactions = transactions;
    }

    ...

    Double getCredit() {
        if (cachedCredit == null) {
            cachedCredit = transactions
                .map(transaction -> transaction.getCredit())
                .sum();
        }
        return cachedCredit;
    }

    Double getDebit() {
        if (cachedDebit == null) {
            cachedDebit = transactions
                .map(transaction -> transaction.getEdbit())
                .sum();
        }
        return cachedCredit;
    }

    Double getBalance() {
        return getCredit() - getDebit();
    }
}
```

</br>

# 6. 논리에 대한 진실의 원천을 하나만 가져야 한다.
- 코드의 두 부분이 서로 일치하지 않으면 소프트웨어가 제대로 작동하지 않을 것이다. 그러므로 논리를 위한 진실의 원천 역시 단 하나만 존재하도록 하는 것이 중요하다.

## 6.1 논리에 대한 진실이 여러 개 있으면 버그를 유발할 수 있다.

```java
// 직렬화
class DataLogger {
    private final List<Int> loggedValues;
    ...

    saveValues(FileHandler file) {
        String serializedValues = loggedValues
            .map(value -> value.toString(Radix.BASE_10))
            .join(",");
        file.write(serializedValues);
    }
}
```

```java
// 역직렬화
class DataLoader {
    ...

    List<Int> loadValues(FileHandler file) {
        return file.readAsString()
            .split(",")
            .map(str -> Int.parse(str, Radix.BASE_10));
    }
}
```

- 한 클래스가 수정되고 다른 클래스가 수정되지 않으면 문제가 발생한다.

## 6.2 해결책: 진실의 원천은 단 하나만 있어야 한다.

![그림 7.7]

```java
class IntListFormat {
    private const String DELIMITER = ",";
    private const Radix RADIX = Radix.BASE_10;

    String serialize(List<Int> values) {
        return values
            .map(value -> value.toString(RADIX))
            .join(DELIMETER);
    }

    List<Int> deserialize(String serialized) {
        return serialized
            .split(DELIMETER)
            .map(str -> Int.parse(str, RADIX));
    }
}

class DataLogger {
    private final List<Int> loggedValues;
    private final IntListFormat intListFormat;
    ...
    saveValues(FileHandler file) {
        file.write(intListFormat.serialize(loggedValues));
    }
}

class DataLoader {
    private final IntListFormat intListFormat;
    ...
    List<Int> loadValues(FileHandler file) {
        return intListFormat.deserialize(file.readAsString());
    }
}
```

![그림 7.8]

- 중요한 논리에 대해 진실의 원천이 하나만 존재하도록 하면 코드가 훨씬 더 견고해진다.

</br>

# 요약
- 코드가 오용되기 쉽게 작성되고 나면 어느 시점에선가는 오용될 가능성이 크고 이것은 버그로 이어질 수 있다.
- 코드가 오용되는 몇 가지 일반적인 사례는 다음과 같다.
  - 호출하는 쪽에서 잘못된 입력을 제공
  - 다른 코드에서 일어나는 부수 효과
  - 함수 호출 시점이 잘못되거나 올바른 순서로 호출되지 않은 경우
  - 원래의 코드에 연관된 코드를 수정할 때 원래의 코드가 내포한 가정과 어긋나게 수정하는 경우
- 오용이 어렵거나 불가능하도록 코드를 설계하고 구조화하는 것이 종종 가능하다. 이를 통해 버그 발생 가능성이 크게 줄어들고 중장기적으로 개발자의 시간을 많이 절약할 수 있다.
