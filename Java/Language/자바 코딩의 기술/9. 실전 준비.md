# 9. 실전 준비

## 1. 정적 코드 분석 도구
- 정적 분석 도구는 코드 품질을 가늠하는 일종의 바이다.
- 코드를 분석하고 잠재적인 버그나 코드 스멜을 찾는다.
- `SpotBugs`, `FindBugs`, `Checkstyle`, `PMD`, `Error Prone`, `Code Inspection(intelliJ)`
- 최소한 하나는 적용해야 고품질로 유지보수하기 쉽다.

</br>

## 2. 팀 내 자바 포맷 통일
- 궁극적으로 옳고 그름은 없으나, 계속된 재서식화나 버그를 피하려면 팀원 전원이 하나의 일관된 서식화 방식에 동의해야 한다.
- 모두가 동의할 수 있는 형식만 찾으면 대부분 해결됩니다.

</br>

## 3. 빌드 자동화
- 모든 시스템에서 같은 방식으로 동작하면서 개발자 장비와 독립적인 정교한 빌드 도구나 언어로 빌드를 자동화한다.

</br>

## 4. 지속적 통합
- 광범위한 테스트와 통합, 코드 품질 검증 등 모든 과정을 지속적 통합 서버라는 전용 장비에 위탁할 수 있다.
- 버전 제어 시스템에 커밋할 때마다 전용 서버가 코드를 모두 가져와 전체 테스트를 실행하고 완벽히 통합된 실행 파일을 빌드하게 한다.

</br>

## 5. 생산 준비와 납품
- 대비의 일환으로 로그, 수치, 대시보드, 알람 형태로 감시를 구현한다.
- `Open Source Elastic Stack`, `Graylog`
- 자동으로 예외를 모으고 추적하는 것으로 백엔드는`Airbrake`, 프론트는 `Sentry`가 있다.

</br>

## 6. 콘솔 출력 대신 로깅
- 로깅 프레임워크 설정을 통해 어떤 로그 명령문은 파일에 저장하고 어떤 것은 네트워크로 보내고 심지어 어떤 것은 원하는 콘솔에 출력할 수 있다.
- 로그레벨로 명령문의 심각도를 표현할 수 있다.

</br>

## 7. 다중 스레드 코드 최소화 및 독립
- 성능 벤치마크에서 심각한 결과가 나오는 등 적절한 근거가 생기기 전에는 때이른 최적화와 다중 스레드 코딩은 하지말자.
- 코드를 측정한 후 너무 느릴 때만 다중 스레드를 활용하자.
- 그래도 동시 실행 코드를 작성한다면 프로그램을 훌륭히 구조화하는 데 집중해야 한다.
- 코드 기반에서 최소한의 패키지에만 제한시키는 등 가능하면 다중 스레드 코드를 독립적으로 분리시키고 완벽히 설명하길 바란다.
- 가변 데이터는 경합 조건이나 갱신 무효와 같은 동시 실행 버그를 일으키기 쉬우므로, 가변 데이터를 가능한 적게 사용해야 한다.

</br>

## 8. 고급 동시 실행 추상화 사용하기
- `Semaphore`, `CountDownLatch`, `CyclingBarrier`, `AtomicInteger`, `LongAdder`, `ConcurrentHashMap`, `CopyOnWriteArrayList`, `BlockingQueue`와 같은 클래스를 올바르게 사용하려면 자바 메모리 모델과 모델 내 상태 변경 간 전후 관계가 어떻게 동작하는지 완벽히 이해해야 한다.

</br>

## 9. 프로그램 속도 향상
- 부수효과가 없는 순차적 스트림은 작업을 코어 여러 개에 분산해 병렬로 작업을 실행할 수 있다.

```java
return supplies.stream()
    .parallel()
    .filter(Supply::isUncontaminated)
    .map(Supply::getName)
    .distinct()
    .count();
```

- 부수효과가 없고 매 처리 단계가 서로 독립적일 때만 제대로 동작한다.

</br>

## 10. 틀린 가정 알기
- 함부로 너무 많이 가정하면 안 되고 틀렸다고 증명될 상황에 대처하려고 코드를 유연하게 만들어도 안 된다.

```java
NameTag(String name) {
    Object.requireNonNull(name);
    this.name = name;
}
```

- 코드에서 너무 많이 가정하지 말고 그 작업을 그냥 클래스의 사용자에게 넘겨라.
- 현실 세계에 맞도록 코드를 준비하려면 순전히 가정만으로 코드가 이끌려 가기 전에 항상 한 번 더 생각해라.
